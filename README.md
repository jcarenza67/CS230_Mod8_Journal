## CS-230 Module Eight Journal - Software Design Reflection

### Summary of The Gaming Room Client and Software Requirements
The Gaming Room is a fictional client that wanted to expand their Android-only game, *Draw It or Lose It*, into a web-based, multi-platform game. The game involves teams trying to guess drawings that are revealed over time. the client wanted a scalable and maintainable solution that could support multiple players, teams, and rounds, with unique names for each. The software needed to be designed using OOP and should work well in a distributed, cloud-based environment.
### What I Did Well
I think I did a good job organizing and writing the software design document clearly. Each section was broken down and directly addressed the client's needs. I also stayed ahead by completing the Evaluation and Recommendations sections a little early so that updating later would be much easier and focused. I made sure the technical details were explained in a way that makes sense to both devs and clients.
### What I Found Helpful During the Process
Working through the software design document helped me better understand how everything fits together before writing any code. It forced me to think about architecture, design patterns, scalability, and edge cases up front. Having a clear plan can make coding feel more strucatured and intentional instead if just jumping straight into implementation.
### What I Would Revise
If I had to revise or add one part, I would focus on the System Architecture View section. It wasn't required, so I skipped it, but it hindsight it would've been useful practice to map out the system layers, how the frontend and backend communicate, and where things APIs, databases, and containers fit in.
### Interpreting User Needs
I interpreted the user's needs by reading the client requirements carefully and focusing on functionality that directly impacted players, like unique names for teams and games, supporting multiple users per team, and making the game web-accessible. Considering the user's needs helps ensure the software is actually usable and solves the right problem. It also helps guide what features should be prioritized.
### My Approach to Software Design
I started breaking down the requirements and then planning out how the pieces would connect, using design patterns like Singleton and Iterator, and thinking about how the backend would scale. For future projects, I would continue using a modular approach and take time to map out the domain model and system architecture early. I would also rely more on user stories or personas to stay focused on how people will actually use the app.
